/**
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

module dateparser;

debug(dateparser) import std.stdio;
import std.datetime;
import std.traits;
import std.typecons;
import std.regex;
import std.range;
import std.experimental.allocator.common;
import std.experimental.allocator.gc_allocator;
import dateparser.timelexer;
import dateparser.ymd;
import dateparser.parseresult;
public import dateparser.parserinfo;

private:

Parser!GCAllocator defaultParser;
static this()
{
    defaultParser = new Parser!GCAllocator(new ParserInfo());
}

/**
 * Parse a I[.F] seconds value into (seconds, microseconds)
 *
 * Params:
 *     value = value to parse
 * Returns:
 *     tuple of two `int`s
 */
auto parseMS(R)(R s) if (
    isForwardRange!R &&
    !isInfinite!R &&
    isSomeChar!(ElementEncodingType!R))
{
    import std.string : leftJustifier;
    import std.algorithm.searching : canFind;
    import std.algorithm.iteration : splitter;
    import std.typecons : tuple;
    import std.conv : parse;
    import std.utf : byCodeUnit;

    // auto decoding special case
    static if (isNarrowString!R)
        auto value = s.byCodeUnit;
    else
        alias value = s;

    if (!(value.save.canFind('.')))
    {
        return tuple(parse!int(value), 0);
    }
    else
    {
        auto splitValue = value.splitter('.');
        auto secs = splitValue.front;
        splitValue.popFront();
        auto msecs = splitValue.front.leftJustifier(6, '0');
        return tuple(
            parse!int(secs),
            parse!int(msecs)
        );
    }
}

pure unittest
{
    import std.typecons : tuple;
    import std.utf : byChar;

    auto s = "123";
    assert(s.parseMS == tuple(123, 0));

    auto s2 = "123.4";
    assert(s2.parseMS == tuple(123, 400000));

    auto s3 = "123.4567".byChar;
    assert(s3.parseMS == tuple(123, 456700));
}

void setAttribute(P, T)(ref P p, string name, auto ref T value)
{
    foreach (mem; __traits(allMembers, P))
    {
        static if (is(typeof(__traits(getMember, p, mem)) Q))
        {
            static if (is(T : Q))
            {
                if (mem == name)
                {
                    __traits(getMember, p, mem) = value;
                    return;
                }
            }
        }
    }
    assert(0, P.stringof ~ " has no member " ~ name);
}

public:

/**
This function offers a generic date/time string Parser which is able to parse
most known formats to represent a date and/or time.

This function attempts to be forgiving with regards to unlikely input formats,
returning a `SysTime` object even for dates which are ambiguous.

If an element of a date/time stamp is omitted, the following rules are applied:

$(UL
    $(LI If AM or PM is left unspecified, a 24-hour clock is assumed, however,
    an hour on a 12-hour clock (0 <= hour <= 12) *must* be specified if
    AM or PM is specified.)
    $(LI If a time zone is omitted, a SysTime is given with the timezone of the
    host machine.)
)

Missing information is allowed, and what ever is given is applied on top of
the `defaultDate` parameter, which defaults to January 1, 1 AD at midnight.
E.g. a string of `"10:00 AM"` with a `defaultDate` of
`SysTime(Date(2016, 1, 1))` will yield `SysTime(DateTime(2016, 1, 1, 10, 0, 0))`.

If your date string uses timezone names in place of UTC offsets, then timezone
information must be user provided, as there is no way to reliably get timezones
from the OS by abbreviation. But, the timezone will be properly set if an offset
is given. Timezone info and their abbreviations change constantly, so it's a
good idea to not rely on `timezoneInfos` too much.

This function allocates memory and throws on the GC. In order to reduce GC allocations,
use a custom `Parser` instance with a different allocator.

Unicode_Specifics:
    $(OL
        $(LI The AA key comparisons done with `ParserInfo` are on a code unit by code
        unit basis. As such, if user data passed to this function has a different
        normalization than the AAs in the used `ParserInfo` class, then you will
        get parser exceptions.)
        $(LI While other languages have writing systems without Arabic numerals,
        the overwhelming majority of dates are written with them. As such,
        this function does not work with other number systems and expects ASCII
        numbers.)
    )

Params:
    timeString = A forward range containing a date/time stamp.
    ignoreTimezone = Set to false by default, time zones in parsed strings are ignored and a
               SysTime with the local time zone is returned. If timezone information
               is not important, setting this to true is slightly faster.
    timezoneInfos = Time zone names / aliases which may be present in the
              string. This argument maps time zone names (and optionally offsets
              from those time zones) to time zones. This parameter is ignored if
              ignoreTimezone is set.
    dayFirst = Whether to interpret the first value in an ambiguous 3-integer date
              (e.g. 01/05/09) as the day (`true`) or month (`false`). If
              yearFirst is set to true, this distinguishes between YDM and
              YMD.
    yearFirst = Whether to interpret the first value in an ambiguous 3-integer date
                (e.g. 01/05/09) as the year. If true, the first number is taken to
                be the year, otherwise the last number is taken to be the year.
    fuzzy = Whether to allow fuzzy parsing, allowing for string like "Today is
            January 1, 2047 at 8:21:00AM".
    defaultDate = The date to apply the given information on top of. Defaults to
    January 1st, 1 AD

Returns:
    A SysTime object representing the parsed string

Throws:
    `ConvException` will be thrown for invalid string or unknown string format

Throws:
    `TimeException` if the date string is successfully parsed but the created
    date would be invalid

Throws:
    `ConvOverflowException` if one of the numbers in the parsed date exceeds
    `float.max`
*/
SysTime parse(Range)(Range timeString,
    Flag!"ignoreTimezone" ignoreTimezone = No.ignoreTimezone,
    const(TimeZone)[string] timezoneInfos = null,
    Flag!"dayFirst" dayFirst = No.dayFirst,
    Flag!"yearFirst" yearFirst = No.yearFirst,
    Flag!"fuzzy" fuzzy = No.fuzzy,
    SysTime defaultDate = SysTime(DateTime(1, 1, 1))) if (
        isForwardRange!Range && !isInfinite!Range && isSomeChar!(ElementEncodingType!Range))
{
    // dfmt off
    return defaultParser.parse(
        timeString,
        ignoreTimezone,
        timezoneInfos,
        dayFirst,
        yearFirst,
        fuzzy,
        defaultDate
    );
}

///
unittest
{
    immutable brazilTime = new SimpleTimeZone(dur!"seconds"(-10_800));
    const(TimeZone)[string] timezones = ["BRST" : brazilTime];

    immutable parsed = parse("Thu Sep 25 10:36:28 BRST 2003", No.ignoreTimezone, timezones);
    // SysTime opEquals ignores timezones
    assert(parsed == SysTime(DateTime(2003, 9, 25, 10, 36, 28)));
    assert(parsed.timezone == brazilTime);

    assert(parse(
        "2003 10:36:28 BRST 25 Sep Thu",
        No.ignoreTimezone,
        timezones
    ) == SysTime(DateTime(2003, 9, 25, 10, 36, 28)));
    assert(parse("Thu Sep 25 10:36:28") == SysTime(DateTime(1, 9, 25, 10, 36, 28)));
    assert(parse("20030925T104941") == SysTime(DateTime(2003, 9, 25, 10, 49, 41)));
    assert(parse("2003-09-25T10:49:41") == SysTime(DateTime(2003, 9, 25, 10, 49, 41)));
    assert(parse("10:36:28") == SysTime(DateTime(1, 1, 1, 10, 36, 28)));
    assert(parse("09-25-2003") == SysTime(DateTime(2003, 9, 25)));
}

/// Apply information on top of `defaultDate`
unittest
{
    assert("10:36:28".parse(No.ignoreTimezone, null, No.dayFirst, No.yearFirst,
        No.fuzzy, SysTime(DateTime(2016, 3, 15)))
    == SysTime(DateTime(2016, 3, 15, 10, 36, 28)));
    assert("August 07".parse(No.ignoreTimezone, null, No.dayFirst, No.yearFirst,
        No.fuzzy, SysTime(DateTime(2016, 1, 1)))
    == SysTime(Date(2016, 8, 7)));
    assert("2000".parse(No.ignoreTimezone, null, No.dayFirst, No.yearFirst,
        No.fuzzy, SysTime(DateTime(2016, 3, 1)))
    == SysTime(Date(2000, 3, 1)));
}

/// Custom allocators
unittest
{
    import std.experimental.allocator.mallocator : Mallocator;

    auto customParser = new Parser!Mallocator(new ParserInfo());
    assert(customParser.parse("2003-09-25T10:49:41") ==
        SysTime(DateTime(2003, 9, 25, 10, 49, 41)));
}

/// Exceptions
unittest
{
    import std.exception : assertThrown;
    import std.conv : ConvException;

    assertThrown!ConvException(parse(""));
    assertThrown!ConvException(parse("AM"));
    assertThrown!ConvException(parse("The quick brown fox jumps over the lazy dog"));
    assertThrown!TimeException(parse("Feb 30, 2007"));
    assertThrown!TimeException(parse("Jan 20, 2015 PM"));
    assertThrown!ConvException(parse("01-Jane-01"));
    assertThrown!ConvException(parse("13:44 AM"));
    assertThrown!ConvException(parse("January 25, 1921 23:13 PM"));
}
// dfmt on

unittest
{
    assert(parse("Thu Sep 10:36:28") == SysTime(DateTime(1, 9, 5, 10, 36, 28)));
    assert(parse("Thu 10:36:28") == SysTime(DateTime(1, 1, 3, 10, 36, 28)));
    assert(parse("Sep 10:36:28") == SysTime(DateTime(1, 9, 1, 10, 36, 28)));
    assert(parse("Sep 2003") == SysTime(DateTime(2003, 9, 1)));
    assert(parse("Sep") == SysTime(DateTime(1, 9, 1)));
    assert(parse("2003") == SysTime(DateTime(2003, 1, 1)));
    assert(parse("10:36") == SysTime(DateTime(1, 1, 1, 10, 36)));
}

unittest
{
    assert(parse("Thu 10:36:28") == SysTime(DateTime(1, 1, 3, 10, 36, 28)));
    assert(parse("20030925T104941") == SysTime(DateTime(2003, 9, 25, 10, 49, 41)));
    assert(parse("20030925T1049") == SysTime(DateTime(2003, 9, 25, 10, 49, 0)));
    assert(parse("20030925T10") == SysTime(DateTime(2003, 9, 25, 10)));
    assert(parse("20030925") == SysTime(DateTime(2003, 9, 25)));
    assert(parse("2003-09-25 10:49:41,502") == SysTime(DateTime(2003, 9, 25, 10,
        49, 41), msecs(502)));
    assert(parse("199709020908") == SysTime(DateTime(1997, 9, 2, 9, 8)));
    assert(parse("19970902090807") == SysTime(DateTime(1997, 9, 2, 9, 8, 7)));
}

unittest
{
    assert(parse("2003 09 25") == SysTime(DateTime(2003, 9, 25)));
    assert(parse("2003 Sep 25") == SysTime(DateTime(2003, 9, 25)));
    assert(parse("25 Sep 2003") == SysTime(DateTime(2003, 9, 25)));
    assert(parse("25 Sep 2003") == SysTime(DateTime(2003, 9, 25)));
    assert(parse("Sep 25 2003") == SysTime(DateTime(2003, 9, 25)));
    assert(parse("09 25 2003") == SysTime(DateTime(2003, 9, 25)));
    assert(parse("25 09 2003") == SysTime(DateTime(2003, 9, 25)));
    assert(parse("10 09 2003", No.ignoreTimezone, null,
        Yes.dayFirst) == SysTime(DateTime(2003, 9, 10)));
    assert(parse("10 09 2003") == SysTime(DateTime(2003, 10, 9)));
    assert(parse("10 09 03") == SysTime(DateTime(2003, 10, 9)));
    assert(parse("10 09 03", No.ignoreTimezone, null, No.dayFirst,
        Yes.yearFirst) == SysTime(DateTime(2010, 9, 3)));
    assert(parse("25 09 03") == SysTime(DateTime(2003, 9, 25)));
}

unittest
{
    assert(parse("03 25 Sep") == SysTime(DateTime(2003, 9, 25)));
    assert(parse("2003 25 Sep") == SysTime(DateTime(2003, 9, 25)));
    assert(parse("25 03 Sep") == SysTime(DateTime(2025, 9, 3)));
    assert(parse("Thu Sep 25 2003") == SysTime(DateTime(2003, 9, 25)));
    assert(parse("Sep 25 2003") == SysTime(DateTime(2003, 9, 25)));
}

// Naked times
unittest
{
    assert(parse("10h36m28.5s") == SysTime(DateTime(1, 1, 1, 10, 36, 28), msecs(500)));
    assert(parse("10h36m28s") == SysTime(DateTime(1, 1, 1, 10, 36, 28)));
    assert(parse("10h36m") == SysTime(DateTime(1, 1, 1, 10, 36)));
    assert(parse("10h") == SysTime(DateTime(1, 1, 1, 10, 0, 0)));
    assert(parse("10 h 36") == SysTime(DateTime(1, 1, 1, 10, 36, 0)));
    assert(parse("10 hours 36 minutes") == SysTime(DateTime(1, 1, 1, 10, 36, 0)));
}

// AM vs PM
unittest
{
    assert(parse("10h am") == SysTime(DateTime(1, 1, 1, 10)));
    assert(parse("10h pm") == SysTime(DateTime(1, 1, 1, 22)));
    assert(parse("10am") == SysTime(DateTime(1, 1, 1, 10)));
    assert(parse("10pm") == SysTime(DateTime(1, 1, 1, 22)));
    assert(parse("12 am") == SysTime(DateTime(1, 1, 1, 0, 0)));
    assert(parse("12am") == SysTime(DateTime(1, 1, 1, 0, 0)));
    assert(parse("11 pm") == SysTime(DateTime(1, 1, 1, 23, 0)));
    assert(parse("10:00 am") == SysTime(DateTime(1, 1, 1, 10)));
    assert(parse("10:00 pm") == SysTime(DateTime(1, 1, 1, 22)));
    assert(parse("10:00am") == SysTime(DateTime(1, 1, 1, 10)));
    assert(parse("10:00pm") == SysTime(DateTime(1, 1, 1, 22)));
    assert(parse("10:00a.m") == SysTime(DateTime(1, 1, 1, 10)));
    assert(parse("10:00p.m") == SysTime(DateTime(1, 1, 1, 22)));
    assert(parse("10:00a.m.") == SysTime(DateTime(1, 1, 1, 10)));
    assert(parse("10:00p.m.") == SysTime(DateTime(1, 1, 1, 22)));
}

// ISO and ISO stripped
unittest
{
    immutable zone = new SimpleTimeZone(dur!"seconds"(-10_800));

    immutable parsed = parse("2003-09-25T10:49:41.5-03:00");
    assert(parsed == SysTime(DateTime(2003, 9, 25, 10, 49, 41), msecs(500), zone));
    assert((cast(immutable(SimpleTimeZone)) parsed.timezone).utcOffset == hours(-3));

    immutable parsed2 = parse("2003-09-25T10:49:41-03:00");
    assert(parsed2 == SysTime(DateTime(2003, 9, 25, 10, 49, 41), zone));
    assert((cast(immutable(SimpleTimeZone)) parsed2.timezone).utcOffset == hours(-3));

    assert(parse("2003-09-25T10:49:41") == SysTime(DateTime(2003, 9, 25, 10, 49, 41)));
    assert(parse("2003-09-25T10:49") == SysTime(DateTime(2003, 9, 25, 10, 49)));
    assert(parse("2003-09-25T10") == SysTime(DateTime(2003, 9, 25, 10)));
    assert(parse("2003-09-25") == SysTime(DateTime(2003, 9, 25)));

    immutable parsed3 = parse("2003-09-25T10:49:41-03:00");
    assert(parsed3 == SysTime(DateTime(2003, 9, 25, 10, 49, 41), zone));
    assert((cast(immutable(SimpleTimeZone)) parsed3.timezone).utcOffset == hours(-3));

    immutable parsed4 = parse("20030925T104941-0300");
    assert(parsed4 == SysTime(DateTime(2003, 9, 25, 10, 49, 41), zone));
    assert((cast(immutable(SimpleTimeZone)) parsed4.timezone).utcOffset == hours(-3));

    assert(parse("20030925T104941") == SysTime(DateTime(2003, 9, 25, 10, 49, 41)));
    assert(parse("20030925T1049") == SysTime(DateTime(2003, 9, 25, 10, 49, 0)));
    assert(parse("20030925T10") == SysTime(DateTime(2003, 9, 25, 10)));
    assert(parse("20030925") == SysTime(DateTime(2003, 9, 25)));
}

// Dashes
unittest
{
    assert(parse("2003-09-25") == SysTime(DateTime(2003, 9, 25)));
    assert(parse("2003-Sep-25") == SysTime(DateTime(2003, 9, 25)));
    assert(parse("25-Sep-2003") == SysTime(DateTime(2003, 9, 25)));
    assert(parse("25-Sep-2003") == SysTime(DateTime(2003, 9, 25)));
    assert(parse("Sep-25-2003") == SysTime(DateTime(2003, 9, 25)));
    assert(parse("09-25-2003") == SysTime(DateTime(2003, 9, 25)));
    assert(parse("25-09-2003") == SysTime(DateTime(2003, 9, 25)));
    assert(parse("10-09-2003", No.ignoreTimezone, null,
        Yes.dayFirst) == SysTime(DateTime(2003, 9, 10)));
    assert(parse("10-09-2003") == SysTime(DateTime(2003, 10, 9)));
    assert(parse("10-09-03") == SysTime(DateTime(2003, 10, 9)));
    assert(parse("10-09-03", No.ignoreTimezone, null, No.dayFirst,
        Yes.yearFirst) == SysTime(DateTime(2010, 9, 3)));
    assert(parse("01-99") == SysTime(DateTime(1999, 1, 1)));
    assert(parse("99-01") == SysTime(DateTime(1999, 1, 1)));
    assert(parse("13-01", No.ignoreTimezone, null, Yes.dayFirst) == SysTime(DateTime(1,
        1, 13)));
    assert(parse("01-13") == SysTime(DateTime(1, 1, 13)));
    assert(parse("01-99-Jan") == SysTime(DateTime(1999, 1, 1)));
}

// Dots
unittest
{
    assert(parse("2003.09.25") == SysTime(DateTime(2003, 9, 25)));
    assert(parse("2003.Sep.25") == SysTime(DateTime(2003, 9, 25)));
    assert(parse("25.Sep.2003") == SysTime(DateTime(2003, 9, 25)));
    assert(parse("25.Sep.2003") == SysTime(DateTime(2003, 9, 25)));
    assert(parse("Sep.25.2003") == SysTime(DateTime(2003, 9, 25)));
    assert(parse("09.25.2003") == SysTime(DateTime(2003, 9, 25)));
    assert(parse("25.09.2003") == SysTime(DateTime(2003, 9, 25)));
    assert(parse("10.09.2003", No.ignoreTimezone, null,
        Yes.dayFirst) == SysTime(DateTime(2003, 9, 10)));
    assert(parse("10.09.2003") == SysTime(DateTime(2003, 10, 9)));
    assert(parse("10.09.03") == SysTime(DateTime(2003, 10, 9)));
    assert(parse("10.09.03", No.ignoreTimezone, null, No.dayFirst,
        Yes.yearFirst) == SysTime(DateTime(2010, 9, 3)));
}

// Slashes
unittest
{
    assert(parse("2003/09/25") == SysTime(DateTime(2003, 9, 25)));
    assert(parse("2003/Sep/25") == SysTime(DateTime(2003, 9, 25)));
    assert(parse("25/Sep/2003") == SysTime(DateTime(2003, 9, 25)));
    assert(parse("25/Sep/2003") == SysTime(DateTime(2003, 9, 25)));
    assert(parse("Sep/25/2003") == SysTime(DateTime(2003, 9, 25)));
    assert(parse("09/25/2003") == SysTime(DateTime(2003, 9, 25)));
    assert(parse("25/09/2003") == SysTime(DateTime(2003, 9, 25)));
    assert(parse("10/09/2003", No.ignoreTimezone, null,
        Yes.dayFirst) == SysTime(DateTime(2003, 9, 10)));
    assert(parse("10/09/2003") == SysTime(DateTime(2003, 10, 9)));
    assert(parse("10/09/03") == SysTime(DateTime(2003, 10, 9)));
    assert(parse("10/09/03", No.ignoreTimezone, null, No.dayFirst,
        Yes.yearFirst) == SysTime(DateTime(2010, 9, 3)));
}

// Random formats
unittest
{
    assert(parse("Wed, July 10, '96") == SysTime(DateTime(1996, 7, 10, 0, 0)));
    assert(parse("1996.07.10 AD at 15:08:56 PDT",
        Yes.ignoreTimezone) == SysTime(DateTime(1996, 7, 10, 15, 8, 56)));
    assert(parse("1996.July.10 AD 12:08 PM") == SysTime(DateTime(1996, 7, 10, 12, 8)));
    assert(parse("Tuesday, April 12, 1952 AD 3:30:42pm PST",
        Yes.ignoreTimezone) == SysTime(DateTime(1952, 4, 12, 15, 30, 42)));
    assert(parse("November 5, 1994, 8:15:30 am EST",
        Yes.ignoreTimezone) == SysTime(DateTime(1994, 11, 5, 8, 15, 30)));
    assert(parse("1994-11-05T08:15:30-05:00",
        Yes.ignoreTimezone) == SysTime(DateTime(1994, 11, 5, 8, 15, 30)));
    assert(parse("1994-11-05T08:15:30Z",
        Yes.ignoreTimezone) == SysTime(DateTime(1994, 11, 5, 8, 15, 30)));
    assert(parse("July 4, 1976") == SysTime(DateTime(1976, 7, 4)));
    assert(parse("7 4 1976") == SysTime(DateTime(1976, 7, 4)));
    assert(parse("4 jul 1976") == SysTime(DateTime(1976, 7, 4)));
    assert(parse("7-4-76") == SysTime(DateTime(1976, 7, 4)));
    assert(parse("19760704") == SysTime(DateTime(1976, 7, 4)));
    assert(parse("0:01:02") == SysTime(DateTime(1, 1, 1, 0, 1, 2)));
    assert(parse("12h 01m02s am") == SysTime(DateTime(1, 1, 1, 0, 1, 2)));
    assert(parse("0:01:02 on July 4, 1976") == SysTime(DateTime(1976, 7, 4, 0, 1, 2)));
    assert(parse("0:01:02 on July 4, 1976") == SysTime(DateTime(1976, 7, 4, 0, 1, 2)));
    assert(parse("1976-07-04T00:01:02Z",
        Yes.ignoreTimezone) == SysTime(DateTime(1976, 7, 4, 0, 1, 2)));
    assert(parse("July 4, 1976 12:01:02 am") == SysTime(DateTime(1976, 7, 4, 0, 1,
        2)));
    assert(parse("Mon Jan  2 04:24:27 1995") == SysTime(DateTime(1995, 1, 2, 4, 24,
        27)));
    assert(parse("Tue Apr 4 00:22:12 PDT 1995",
        Yes.ignoreTimezone) == SysTime(DateTime(1995, 4, 4, 0, 22, 12)));
    assert(parse("04.04.95 00:22") == SysTime(DateTime(1995, 4, 4, 0, 22)));
    assert(parse("Jan 1 1999 11:23:34.578") == SysTime(DateTime(1999, 1, 1, 11, 23,
        34), msecs(578)));
    assert(parse("950404 122212") == SysTime(DateTime(1995, 4, 4, 12, 22, 12)));
    assert(parse("0:00 PM, PST", Yes.ignoreTimezone) == SysTime(DateTime(1, 1, 1, 12,
        0)));
    assert(parse("12:08 PM") == SysTime(DateTime(1, 1, 1, 12, 8)));
    assert(parse("5:50 A.M. on June 13, 1990") == SysTime(DateTime(1990, 6, 13, 5,
        50)));
    assert(parse("3rd of May 2001") == SysTime(DateTime(2001, 5, 3)));
    assert(parse("5th of March 2001") == SysTime(DateTime(2001, 3, 5)));
    assert(parse("1st of May 2003") == SysTime(DateTime(2003, 5, 1)));
    assert(parse("01h02m03") == SysTime(DateTime(1, 1, 1, 1, 2, 3)));
    assert(parse("01h02") == SysTime(DateTime(1, 1, 1, 1, 2)));
    assert(parse("01h02s") == SysTime(DateTime(1, 1, 1, 1, 0, 2)));
    assert(parse("01m02") == SysTime(DateTime(1, 1, 1, 0, 1, 2)));
    assert(parse("01m02h") == SysTime(DateTime(1, 1, 1, 2, 1)));
    assert(parse("2004 10 Apr 11h30m") == SysTime(DateTime(2004, 4, 10, 11, 30)));
}

// Pertain, weekday, and month
unittest
{
    assert(parse("Sep 03") == SysTime(DateTime(1, 9, 3)));
    assert(parse("Sep of 03") == SysTime(DateTime(2003, 9, 1)));
    assert(parse("Wed") == SysTime(DateTime(1, 1, 2)));
    assert(parse("Wednesday") == SysTime(DateTime(1, 1, 2)));
    assert(parse("October") == SysTime(DateTime(1, 10, 1)));
    assert(parse("31-Dec-00") == SysTime(DateTime(2000, 12, 31)));
}

// Fuzzy
unittest
{
    // Sometimes fuzzy parsing results in AM/PM flag being set without
    // hours - if it's fuzzy it should ignore that.
    auto s1 = "I have a meeting on March 1 1974.";
    auto s2 = "On June 8th, 2020, I am going to be the first man on Mars";

    // Also don't want any erroneous AM or PMs changing the parsed time
    auto s3 = "Meet me at the AM/PM on Sunset at 3:00 AM on December 3rd, 2003";
    auto s4 = "Meet me at 3:00AM on December 3rd, 2003 at the AM/PM on Sunset";
    auto s5 = "Today is 25 of September of 2003, exactly at 10:49:41 with timezone -03:00.";
    auto s6 = "Jan 29, 1945 14:45 AM I going to see you there?";

    assert(parse(s1, No.ignoreTimezone, null, No.dayFirst, No.yearFirst,
        Yes.fuzzy) == SysTime(DateTime(1974, 3, 1)));
    assert(parse(s2, No.ignoreTimezone, null, No.dayFirst, No.yearFirst,
        Yes.fuzzy) == SysTime(DateTime(2020, 6, 8)));
    assert(parse(s3, No.ignoreTimezone, null, No.dayFirst, No.yearFirst,
        Yes.fuzzy) == SysTime(DateTime(2003, 12, 3, 3)));
    assert(parse(s4, No.ignoreTimezone, null, No.dayFirst, No.yearFirst,
        Yes.fuzzy) == SysTime(DateTime(2003, 12, 3, 3)));

    immutable zone = new SimpleTimeZone(dur!"hours"(-3));
    immutable parsed = parse(s5, No.ignoreTimezone, null, No.dayFirst, No.yearFirst,
        Yes.fuzzy);
    assert(parsed == SysTime(DateTime(2003, 9, 25, 10, 49, 41), zone));

    assert(parse(s6, No.ignoreTimezone, null, No.dayFirst, No.yearFirst,
        Yes.fuzzy) == SysTime(DateTime(1945, 1, 29, 14, 45)));
}

// dfmt off
/// Custom parser info allows for international time representation
unittest
{
    import std.utf : byChar;

    class RusParserInfo : ParserInfo
    {
        this()
        {
            monthsAA = ParserInfo.convert([
                ["янв", "Январь"],
                ["фев", "Февраль"],
                ["мар", "Март"],
                ["апр", "Апрель"],
                ["май", "Май"],
                ["июн", "Июнь"],
                ["июл", "Июль"],
                ["авг", "Август"],
                ["сен", "Сентябрь"],
                ["окт", "Октябрь"],
                ["ноя", "Ноябрь"],
                ["дек", "Декабрь"]
            ]);
        }
    }

    auto rusParser = new Parser!GCAllocator(new RusParserInfo());
    immutable parsedTime = rusParser.parse("10 Сентябрь 2015 10:20");
    assert(parsedTime == SysTime(DateTime(2015, 9, 10, 10, 20)));

    immutable parsedTime2 = rusParser.parse("10 Сентябрь 2015 10:20"d.byChar);
    assert(parsedTime2 == SysTime(DateTime(2015, 9, 10, 10, 20)));
}
// dfmt on

// Test ranges
unittest
{
    import std.utf : byCodeUnit, byChar;

    // forward ranges
    assert("10h36m28s".byChar.parse == SysTime(
        DateTime(1, 1, 1, 10, 36, 28)));
    assert("Thu Sep 10:36:28".byChar.parse == SysTime(
        DateTime(1, 9, 5, 10, 36, 28)));

    // bidirectional ranges
    assert("2003-09-25T10:49:41".byCodeUnit.parse == SysTime(
        DateTime(2003, 9, 25, 10, 49, 41)));
    assert("Thu Sep 10:36:28".byCodeUnit.parse == SysTime(
        DateTime(1, 9, 5, 10, 36, 28)));
}

// Test different string types
unittest
{
    import std.meta : AliasSeq;
    import std.conv : to;

    alias StringTypes = AliasSeq!(
        char[], string,
        wchar[], wstring,
        dchar[], dstring
    );

    foreach (T; StringTypes)
    {
        assert("10h36m28s".to!T.parse == SysTime(
            DateTime(1, 1, 1, 10, 36, 28)));
        assert("Thu Sep 10:36:28".to!T.parse == SysTime(
            DateTime(1, 9, 5, 10, 36, 28)));
        assert("2003-09-25T10:49:41".to!T.parse == SysTime(
            DateTime(2003, 9, 25, 10, 49, 41)));
        assert("Thu Sep 10:36:28".to!T.parse == SysTime(
            DateTime(1, 9, 5, 10, 36, 28)));
    }
}

// Issue #1
unittest
{
    assert(parse("Sat, 12 Mar 2016 01:30:59 -0900",
        Yes.ignoreTimezone) == SysTime(DateTime(2016, 3, 12, 01, 30, 59)));
}

/**
 * Implements the parsing functionality for the parse function. If you are
 * using a custom `ParserInfo` many times in the same program, you can avoid
 * unnecessary allocations by using the `Parser.parse` function directly.
 *
 * Params:
 *     Allocator = the allocator type to use
 *     parserInfo = the parser info to reference when parsing
 */
final class Parser(Allocator) if (
    hasMember!(Allocator, "allocate") && hasMember!(Allocator, "deallocate"))
{
    private const ParserInfo info;

public:
    ///
    this(const ParserInfo parserInfo = null)
    {
        if (parserInfo is null)
        {
            info = new ParserInfo();
        }
        else
        {
            info = parserInfo;
        }
    }

    /**
     * This function has the same functionality as the free version of `parse`.
     * The only difference is this will use your custom `ParserInfo` or allocator
     * if provided.
     */
    SysTime parse(Range)(Range timeString,
        Flag!"ignoreTimezone" ignoreTimezone = No.ignoreTimezone,
        const(TimeZone)[string] timezoneInfos = null,
        Flag!"dayFirst" dayFirst = No.dayFirst,
        Flag!"yearFirst" yearFirst = No.yearFirst,
        Flag!"fuzzy" fuzzy = No.fuzzy,
        SysTime defaultDate = SysTime(Date(1, 1, 1))) if (
            isForwardRange!Range && !isInfinite!Range && isSomeChar!(ElementEncodingType!Range))
    {
        import std.conv : to, ConvException;

        auto res = parseImpl(timeString, dayFirst, yearFirst, fuzzy);

        if (res.badData)
            throw new ConvException("Unknown string format");

        if (res.year.isNull() && res.month.isNull() && res.day.isNull()
                && res.hour.isNull() && res.minute.isNull()
                && res.second.isNull() && res.weekday.isNull()
                && res.shortcutResult.isNull() && res.shortcutTimeResult.isNull())
            throw new ConvException("String does not contain a date.");

        if (res.shortcutResult.isNull && res.shortcutTimeResult.isNull)
        {
            if (!res.year.isNull)
                defaultDate.year(res.year);

            if (!res.day.isNull)
                defaultDate.day(res.day);

            if (!res.month.isNull)
                defaultDate.month(to!Month(res.month));

            if (!res.hour.isNull)
                defaultDate.hour(res.hour);

            if (!res.minute.isNull)
                defaultDate.minute(res.minute);

            if (!res.second.isNull)
                defaultDate.second(res.second);

            if (!res.microsecond.isNull)
                defaultDate.fracSecs(usecs(res.microsecond));

            if (!res.weekday.isNull() && (res.day.isNull || !res.day))
            {
                immutable delta_days = daysToDayOfWeek(
                    defaultDate.dayOfWeek(),
                    to!DayOfWeek(res.weekday)
                );
                defaultDate += dur!"days"(delta_days);
            }
        }
        else if (!res.shortcutTimeResult.isNull)
            defaultDate = SysTime(DateTime(Date(
                defaultDate.year,
                defaultDate.month,
                defaultDate.day,
            ), res.shortcutTimeResult.get()));

        if (!ignoreTimezone)
        {
            if (res.tzname in timezoneInfos)
                defaultDate = defaultDate.toOtherTZ(
                    cast(immutable) timezoneInfos[res.tzname]
                );
            else if (res.tzname.length > 0 && (res.tzname == LocalTime().stdName
                    || res.tzname == LocalTime().dstName))
                defaultDate = SysTime(cast(DateTime) defaultDate);
            else if (!res.tzoffset.isNull && res.tzoffset == 0)
                defaultDate = SysTime(cast(DateTime) defaultDate, cast(immutable) UTC());
            else if (!res.tzoffset.isNull && res.tzoffset != 0)
            {
                defaultDate = SysTime(
                    cast(DateTime) defaultDate,
                    new immutable SimpleTimeZone(dur!"seconds"(res.tzoffset), res.tzname)
                );
            }
        }
        else if (ignoreTimezone && !res.shortcutResult.isNull)
            res.shortcutResult = SysTime(cast(DateTime) res.shortcutResult.get);

        if (!res.shortcutResult.isNull)
            return res.shortcutResult.get;
        else
            return defaultDate;
    }

private:
    /**
    * Private method which performs the heavy lifting of parsing, called from
    * `parse`.
    *
    * Params:
    *     timeString = the string to parse.
    *     dayFirst = Whether to interpret the first value in an ambiguous
    *     3-integer date (e.g. 01/05/09) as the day (true) or month (false). If
    *     yearFirst is set to true, this distinguishes between YDM
    *     and YMD. If set to null, this value is retrieved from the
    *     current :class:ParserInfo object (which itself defaults to
    *     false).
    *     yearFirst = Whether to interpret the first value in an ambiguous 3-integer date
    *     (e.g. 01/05/09) as the year. If true, the first number is taken
    *     to be the year, otherwise the last number is taken to be the year.
    *     fuzzy = Whether to allow fuzzy parsing, allowing for string like "Today is
    *     January 1, 2047 at 8:21:00AM".
    */
    ParseResult parseImpl(Range)(Range timeString, bool dayFirst = false,
        bool yearFirst = false, bool fuzzy = false) if (isForwardRange!Range
            && !isInfinite!Range && isSomeChar!(ElementEncodingType!Range))
    {
        import std.algorithm.searching : canFind, countUntil;
        import std.algorithm.iteration : filter;
        import std.uni : isUpper;
        import std.ascii : isDigit;
        import std.utf : byCodeUnit, byChar;
        import std.conv : to, ConvException;
        import containers.dynamicarray : DynamicArray;

        ParseResult res;

        DynamicArray!(string, Allocator, true) tokens;

        static if (is(Unqual!(ElementEncodingType!Range) == dchar) ||
            is(Unqual!(ElementEncodingType!Range) == wchar))
        {
            put(tokens, timeString.save.byChar.timeLexer);
        }
        else static if (isSomeString!Range && is(Unqual!(ElementEncodingType!Range) == char))
        {
            put(tokens, timeString.save.byCodeUnit.timeLexer);
        }
        else
        {
            put(tokens, timeString.save.timeLexer);
        }

        debug(dateparser) writeln("tokens: ", tokens[]);

        //keep up with the last token skipped so we can recombine
        //consecutively skipped tokens (-2 for when i begins at 0).
        int last_skipped_token_i = -2;

        //year/month/day list
        YMD ymd;

        //Index of the month string in ymd
        ptrdiff_t mstridx = -1;

        immutable size_t tokensLength = tokens.length;
        debug(dateparser) writeln("tokensLength: ", tokensLength);
        uint i = 0;
        while (i < tokensLength)
        {
            //Check if it's a number
            Nullable!(float, float.infinity) value;
            string value_repr;
            debug(dateparser) writeln("index: ", i);
            debug(dateparser) writeln("tokens[i]: ", tokens[i]);

            if (tokens[i][0].isDigit)
            {
                value_repr = tokens[i];
                debug(dateparser) writeln("value_repr: ", value_repr);
                value = to!float(value_repr);
            }

            //Token is a number
            if (!value.isNull())
            {
                immutable tokensItemLength = tokens[i].length;
                ++i;

                if (ymd.length == 3 && (tokensItemLength == 2
                        || tokensItemLength == 4) && res.hour.isNull
                        && (i >= tokensLength || (tokens[i] != ":" && info.hms(tokens[i]) == -1)))
                {
                    debug(dateparser) writeln("branch 1");
                    //19990101T23[59]
                    auto s = tokens[i - 1];
                    res.hour = to!int(s[0 .. 2]);

                    if (tokensItemLength == 4)
                    {
                        res.minute = to!int(s[2 .. $]);
                    }
                }
                else if (tokensItemLength == 6 || (tokensItemLength > 6
                        && tokens[i - 1].countUntil('.') == 6))
                {
                    debug(dateparser) writeln("branch 2");
                    //YYMMDD || HHMMSS[.ss]
                    auto s = tokens[i - 1];

                    if (ymd.length == 0 && !tokens[i - 1].canFind('.'))
                    {
                        ymd.put(s[0 .. 2]);
                        ymd.put(s[2 .. 4]);
                        ymd.put(s[4 .. $]);
                    }
                    else
                    {
                        //19990101T235959[.59]
                        res.hour = to!int(s[0 .. 2]);
                        res.minute = to!int(s[2 .. 4]);
                        auto ms = parseMS(s[4 .. $]);
                        res.second = ms[0];
                        res.microsecond = ms[1];
                    }
                }
                else if (tokensItemLength == 8 || tokensItemLength == 12 || tokensItemLength == 14)
                {
                    debug(dateparser) writeln("branch 3");
                    //YYYYMMDD
                    auto s = tokens[i - 1];
                    ymd.put(s[0 .. 4]);
                    ymd.put(s[4 .. 6]);
                    ymd.put(s[6 .. 8]);

                    if (tokensItemLength > 8)
                    {
                        res.hour = to!int(s[8 .. 10]);
                        res.minute = to!int(s[10 .. 12]);

                        if (tokensItemLength > 12)
                        {
                            res.second = to!int(s[12 .. $]);
                        }
                    }
                }
                else if ((i < tokensLength && info.hms(tokens[i]) > -1)
                        || (i + 1 < tokensLength && tokens[i] == " " && info.hms(tokens[i + 1]) > -1))
                {
                    debug(dateparser) writeln("branch 4");
                    //HH[ ]h or MM[ ]m or SS[.ss][ ]s
                    if (tokens[i] == " ")
                    {
                        ++i;
                    }

                    auto idx = info.hms(tokens[i]);

                    while (true)
                    {
                        if (idx == 0)
                        {
                            res.hour = to!int(value.get());

                            if (value % 1)
                                res.minute = to!int(60 * (value % 1));
                        }
                        else if (idx == 1)
                        {
                            res.minute = to!int(value.get());

                            if (value % 1)
                                res.second = to!int(60 * (value % 1));
                        }
                        else if (idx == 2)
                        {
                            auto temp = parseMS(value_repr);
                            res.second = temp[0];
                            res.microsecond = temp[1];
                        }

                        ++i;

                        if (i >= tokensLength || idx == 2)
                            break;

                        //12h00
                        try
                        {
                            value_repr = tokens[i];
                            value = to!float(value_repr);
                        }
                        catch (ConvException)
                        {
                            break;
                        }

                        ++i;
                        ++idx;

                        if (i < tokensLength)
                        {
                            immutable newidx = info.hms(tokens[i]);

                            if (newidx > -1)
                                idx = newidx;
                        }
                    }
                }
                else if (i == tokensLength && tokensLength > 3
                        && tokens[i - 2] == " " && info.hms(tokens[i - 3]) > -1)
                {
                    debug(dateparser) writeln("branch 5");
                    //X h MM or X m SS
                    immutable idx = info.hms(tokens[i - 3]) + 1;

                    if (idx == 1)
                    {
                        res.minute = to!int(value.get());

                        if (value % 1)
                            res.second = to!int(60 * (value % 1));
                        else if (idx == 2)
                        {
                            auto seconds = parseMS(value_repr);
                            res.second = seconds[0];
                            res.microsecond = seconds[1];
                            ++i;
                        }
                    }
                }
                else if (i + 1 < tokensLength && tokens[i] == ":")
                {
                    debug(dateparser) writeln("branch 6");
                    //HH:MM[:SS[.ss]]
                    static if (isSomeString!Range)
                    {
                        if (tokensLength == 5 && info.ampm(tokens[4]) == -1)
                        {
                            try
                            {
                                res.shortcutTimeResult = TimeOfDay.fromISOExtString(timeString);
                                return res;
                            }
                            catch (DateTimeException) {}
                        }
                    }
                    res.hour = to!int(value.get());
                    ++i;
                    value = to!float(tokens[i]);
                    res.minute = to!int(value.get());

                    if (value % 1)
                        res.second = to!int(60 * (value % 1));

                    ++i;

                    if (i < tokensLength && tokens[i] == ":")
                    {
                        auto temp = parseMS(tokens[i + 1]);
                        res.second = temp[0];
                        res.microsecond = temp[1];
                        i += 2;
                    }
                }
                else if (i < tokensLength && (tokens[i] == "-" || tokens[i] == "/"
                        || tokens[i] == "."))
                {
                    debug(dateparser) writeln("branch 7");
                    immutable string separator = tokens[i];
                    ymd.put(value_repr);
                    ++i;

                    if (i < tokensLength && !info.jump(tokens[i]))
                    {
                        if (tokens[i][0].isDigit)
                        {
                            //01-01[-01]
                            static if (isSomeString!Range)
                            {
                                if (tokensLength >= 11)
                                {
                                    try
                                    {
                                        res.shortcutResult = SysTime.fromISOExtString(timeString);
                                        return res;
                                    }
                                    catch (DateTimeException) {}
                                }
                            }
                            
                            ymd.put(tokens[i]);
                        }
                        else
                        {
                            //01-Jan[-01]
                            value = info.month(tokens[i]);

                            if (value > -1)
                            {
                                ymd.put(value.get());
                                mstridx = cast(ptrdiff_t) (ymd.length == 0 ? 0 : ymd.length - 1);
                            }
                            else
                            {
                                res.badData = true;
                                return res;
                            }
                        }

                        ++i;

                        if (i < tokensLength && tokens[i] == separator)
                        {
                            //We have three members
                            ++i;
                            value = info.month(tokens[i]);

                            if (value > -1)
                            {
                                ymd.put(value.get());
                                mstridx = ymd.length - 1;
                            }
                            else
                                ymd.put(tokens[i]);

                            ++i;
                        }
                    }
                }
                else if (i >= tokensLength || info.jump(tokens[i]))
                {
                    debug(dateparser) writeln("branch 8");
                    if (i + 1 < tokensLength && info.ampm(tokens[i + 1]) > -1)
                    {
                        //12 am
                        res.hour = to!int(value.get());

                        if (res.hour < 12 && info.ampm(tokens[i + 1]) == 1)
                            res.hour += 12;
                        else if (res.hour == 12 && info.ampm(tokens[i + 1]) == 0)
                            res.hour = 0;

                        ++i;
                    }
                    else
                    {
                        //Year, month or day
                        ymd.put(value.get());
                    }
                    ++i;
                }
                else if (info.ampm(tokens[i]) > -1)
                {
                    debug(dateparser) writeln("branch 9");
                    //12am
                    res.hour = to!int(value.get());

                    if (res.hour < 12 && info.ampm(tokens[i]) == 1)
                        res.hour += 12;
                    else if (res.hour == 12 && info.ampm(tokens[i]) == 0)
                        res.hour = 0;

                    ++i;
                }
                else if (!fuzzy)
                {
                    debug(dateparser) writeln("branch 10");
                    res.badData = true;
                    return res;
                }
                else
                {
                    debug(dateparser) writeln("branch 11");
                    ++i;
                }
                continue;
            }

            //Check weekday
            value = info.weekday(tokens[i]);
            if (value > -1)
            {
                debug(dateparser) writeln("branch 12");
                res.weekday = to!uint(value.get());
                ++i;
                continue;
            }

            //Check month name
            value = info.month(tokens[i]);
            if (value > -1)
            {
                debug(dateparser) writeln("branch 13");
                ymd.put(value.get);
                assert(mstridx == -1);
                mstridx = ymd.length - 1;

                ++i;
                if (i < tokensLength)
                {
                    if (tokens[i] == "-" || tokens[i] == "/")
                    {
                        //Jan-01[-99]
                        immutable separator = tokens[i];
                        ++i;
                        ymd.put(tokens[i]);
                        ++i;

                        if (i < tokensLength && tokens[i] == separator)
                        {
                            //Jan-01-99
                            ++i;
                            ymd.put(tokens[i]);
                            ++i;
                        }
                    }
                    else if (i + 3 < tokensLength && tokens[i] == " "
                            && tokens[i + 2] == " " && info.pertain(tokens[i + 1]))
                    {
                        //Jan of 01
                        //In this case, 01 is clearly year
                        try
                        {
                            value = to!int(tokens[i + 3]);
                            //Convert it here to become unambiguous
                            ymd.put(convertYear(value.get.to!int()));
                        }
                        catch (ConvException) {}
                        i += 4;
                    }
                }
                continue;
            }

            //Check am/pm
            value = info.ampm(tokens[i]);
            if (value > -1)
            {
                debug(dateparser) writeln("branch 14");
                //For fuzzy parsing, 'a' or 'am' (both valid English words)
                //may erroneously trigger the AM/PM flag. Deal with that
                //here.
                bool valIsAMPM = true;

                //If there's already an AM/PM flag, this one isn't one.
                if (fuzzy && !res.ampm.isNull())
                    valIsAMPM = false;

                //If AM/PM is found and hour is not, raise a ValueError
                if (res.hour.isNull)
                {
                    if (fuzzy)
                        valIsAMPM = false;
                    else
                        throw new ConvException("No hour specified with AM or PM flag.");
                }
                else if (!(0 <= res.hour && res.hour <= 12))
                {
                    //If AM/PM is found, it's a 12 hour clock, so raise 
                    //an error for invalid range
                    if (fuzzy)
                        valIsAMPM = false;
                    else
                        throw new ConvException("Invalid hour specified for 12-hour clock.");
                }

                if (valIsAMPM)
                {
                    if (value == 1 && res.hour < 12)
                        res.hour += 12;
                    else if (value == 0 && res.hour == 12)
                        res.hour = 0;

                    res.ampm = to!uint(value.get());
                }

                ++i;
                continue;
            }

            //Check for a timezone name
            immutable upperItems = tokens[i]
                .byCodeUnit
                .filter!(a => !isUpper(a))
                .walkLength(1);
            if (!res.hour.isNull && tokens[i].length <= 5
                    && res.tzname.length == 0 && res.tzoffset.isNull && upperItems == 0)
            {
                debug(dateparser) writeln("branch 15");
                res.tzname = tokens[i];

                ++i;

                //Check for something like GMT+3, or BRST+3. Notice
                //that it doesn't mean "I am 3 hours after GMT", but
                //"my time +3 is GMT". If found, we reverse the
                //logic so that timezone parsing code will get it
                //right.
                if (i < tokensLength && (tokens[i][0] == '+' || tokens[i][0] == '-'))
                {
                    tokens[i] = tokens[i][0] == '+' ? "-" : "+";
                    res.tzoffset = 0;
                    if (info.utczone(res.tzname))
                    {
                        //With something like GMT+3, the timezone
                        //is *not* GMT.
                        res.tzname = [];
                    }
                }

                continue;
            }

            //Check for a numbered timezone
            if (!res.hour.isNull && (tokens[i] == "+" || tokens[i] == "-"))
            {
                debug(dateparser) writeln("branch 16");
                immutable int signal = tokens[i][0] == '+' ? 1 : -1;
                ++i;
                immutable size_t tokensItemLength = tokens[i].length;

                if (tokensItemLength == 4)
                {
                    //-0300
                    res.tzoffset = to!int(tokens[i][0 .. 2]) * 3600 + to!int(tokens[i][2 .. $]) * 60;
                }
                else if (i + 1 < tokensLength && tokens[i + 1] == ":")
                {
                    //-03:00
                    res.tzoffset = to!int(tokens[i]) * 3600 + to!int(tokens[i + 2]) * 60;
                    i += 2;
                }
                else if (tokensItemLength <= 2)
                {
                    //-[0]3
                    res.tzoffset = to!int(tokens[i]) * 3600;
                }
                else
                {
                    res.badData = true;
                    return res;
                }
                ++i;

                res.tzoffset *= signal;

                //Look for a timezone name between parenthesis
                if (i + 3 < tokensLength)
                {
                    immutable notUpperItems = tokens[i + 2]
                        .byCodeUnit
                        .filter!(a => !isUpper(a))
                        .walkLength(1);
                    if (info.jump(tokens[i]) && tokens[i + 1] == "("
                            && tokens[i + 3] == ")" && 3 <= tokens[i + 2].length
                            && tokens[i + 2].length <= 5 && notUpperItems == 0)
                    {
                        //-0300 (BRST)
                        res.tzname = tokens[i + 2];
                        i += 4;
                    }
                }
                continue;
            }

            //Check jumps
            if (!(info.jump(tokens[i]) || fuzzy))
            {
                debug(dateparser) writeln("branch 17");
                res.badData = true;
                return res;
            }

            last_skipped_token_i = i;
            ++i;
        }

        auto ymdResult = ymd.resolveYMD(tokens[], mstridx, yearFirst, dayFirst);

        // year
        if (ymdResult[0] > -1)
        {
            res.year = ymdResult[0];
            res.centurySpecified = ymd.centurySpecified;
        }

        // month
        if (ymdResult[1] > 0)
            res.month = ymdResult[1];

        // day
        if (ymdResult[2] > 0)
            res.day = ymdResult[2];

        info.validate(res);
        return res;
    }
}
